import {
  encodeExecutionCalldatas
} from "./chunk-TPBFVDVM.mjs";
import {
  encodePermissionContexts
} from "./chunk-TEH426Y4.mjs";

// src/write.ts
import { SimpleFactory, DelegationManager } from "@metamask/delegation-abis";
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error("RedeemDelegations invalid zero redemptions");
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = encodePermissionContexts(permissionContexts);
  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: DelegationManager,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
async function deployContract(walletClient, publicClient, chain, { bytecode, abi }, args = []) {
  if (!walletClient.account) {
    throw new Error("Wallet client account is required");
  }
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args,
    account: walletClient.account,
    chain
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  if (!receipt.contractAddress) {
    throw new Error("No contract address in receipt");
  }
  return { address: receipt.contractAddress, hash, receipt };
}

// src/smartAccountsEnvironment.ts
import {
  EntryPoint,
  SimpleFactory as SimpleFactory2,
  DelegationManager as DelegationManager2,
  MultiSigDeleGator,
  HybridDeleGator,
  EIP7702StatelessDeleGator,
  SCL_RIP7212,
  AllowedTargetsEnforcer,
  AllowedMethodsEnforcer,
  DeployedEnforcer,
  TimestampEnforcer,
  NonceEnforcer,
  AllowedCalldataEnforcer,
  BlockNumberEnforcer,
  LimitedCallsEnforcer,
  ERC20BalanceChangeEnforcer,
  ERC20StreamingEnforcer,
  IdEnforcer,
  ERC20TransferAmountEnforcer,
  ValueLteEnforcer,
  NativeTokenTransferAmountEnforcer,
  NativeBalanceChangeEnforcer,
  NativeTokenStreamingEnforcer,
  NativeTokenPaymentEnforcer,
  RedeemerEnforcer,
  ArgsEqualityCheckEnforcer,
  ERC721BalanceChangeEnforcer,
  ERC721TransferEnforcer,
  ERC1155BalanceChangeEnforcer,
  OwnershipTransferEnforcer,
  SpecificActionERC20TransferBatchEnforcer,
  ERC20PeriodTransferEnforcer,
  NativeTokenPeriodTransferEnforcer,
  ExactCalldataBatchEnforcer,
  ExactCalldataEnforcer,
  ExactExecutionEnforcer,
  ExactExecutionBatchEnforcer,
  MultiTokenPeriodEnforcer
} from "@metamask/delegation-abis";
import {
  EntryPoint as EntryPointBytecode,
  SimpleFactory as SimpleFactoryBytecode,
  DelegationManager as DelegationManagerBytecode,
  MultiSigDeleGator as MultiSigDeleGatorBytecode,
  HybridDeleGator as HybridDeleGatorBytecode,
  EIP7702StatelessDeleGator as EIP7702StatelessDeleGatorBytecode,
  SCL_RIP7212 as SCLRIP7212Bytecode,
  AllowedTargetsEnforcer as AllowedTargetsEnforcerBytecode,
  AllowedMethodsEnforcer as AllowedMethodsEnforcerBytecode,
  DeployedEnforcer as DeployedEnforcerBytecode,
  TimestampEnforcer as TimestampEnforcerBytecode,
  NonceEnforcer as NonceEnforcerBytecode,
  AllowedCalldataEnforcer as AllowedCalldataEnforcerBytecode,
  BlockNumberEnforcer as BlockNumberEnforcerBytecode,
  LimitedCallsEnforcer as LimitedCallsEnforcerBytecode,
  ERC20BalanceChangeEnforcer as ERC20BalanceChangeEnforcerBytecode,
  ERC20StreamingEnforcer as ERC20StreamingEnforcerBytecode,
  IdEnforcer as IdEnforcerBytecode,
  ERC20TransferAmountEnforcer as ERC20TransferAmountEnforcerBytecode,
  ValueLteEnforcer as ValueLteEnforcerBytecode,
  NativeTokenTransferAmountEnforcer as NativeTokenTransferAmountEnforcerBytecode,
  NativeBalanceChangeEnforcer as NativeBalanceChangeEnforcerBytecode,
  NativeTokenStreamingEnforcer as NativeTokenStreamingEnforcerBytecode,
  NativeTokenPaymentEnforcer as NativeTokenPaymentEnforcerBytecode,
  RedeemerEnforcer as RedeemerEnforcerBytecode,
  ArgsEqualityCheckEnforcer as ArgsEqualityCheckEnforcerBytecode,
  ERC721BalanceChangeEnforcer as ERC721BalanceChangeEnforcerBytecode,
  ERC721TransferEnforcer as ERC721TransferEnforcerBytecode,
  ERC1155BalanceChangeEnforcer as ERC1155BalanceChangeEnforcerBytecode,
  OwnershipTransferEnforcer as OwnershipTransferEnforcerBytecode,
  SpecificActionERC20TransferBatchEnforcer as SpecificActionERC20TransferBatchEnforcerBytecode,
  ERC20PeriodTransferEnforcer as ERC20PeriodTransferEnforcerBytecode,
  NativeTokenPeriodTransferEnforcer as NativeTokenPeriodTransferEnforcerBytecode,
  ExactCalldataBatchEnforcer as ExactCalldataBatchEnforcerBytecode,
  ExactCalldataEnforcer as ExactCalldataEnforcerBytecode,
  ExactExecutionEnforcer as ExactExecutionEnforcerBytecode,
  ExactExecutionBatchEnforcer as ExactExecutionBatchEnforcerBytecode,
  MultiTokenPeriodEnforcer as MultiTokenPeriodEnforcerBytecode
} from "@metamask/delegation-abis/bytecode";
import { DELEGATOR_CONTRACTS } from "@metamask/delegation-deployments";
var PREFERRED_VERSION = "1.3.0";
var contractOverrideMap = /* @__PURE__ */ new Map();
var getContractOverrideKey = (chainId, version) => `${version}:${chainId}`;
function overrideDeployedEnvironment(chainId, version, environment) {
  contractOverrideMap.set(
    getContractOverrideKey(chainId, version),
    environment
  );
}
function getSmartAccountsEnvironment(chainId, version = PREFERRED_VERSION) {
  const overrideKey = getContractOverrideKey(chainId, version);
  const overriddenContracts = contractOverrideMap.get(overrideKey);
  if (overriddenContracts) {
    return overriddenContracts;
  }
  const contracts = DELEGATOR_CONTRACTS[version]?.[chainId];
  if (!contracts) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getSmartAccountsEnvironmentV1(contracts);
}
function getSmartAccountsEnvironmentV1(contracts) {
  return {
    DelegationManager: contracts.DelegationManager,
    EntryPoint: contracts.EntryPoint,
    SimpleFactory: contracts.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,
      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: contracts.BlockNumberEnforcer,
      DeployedEnforcer: contracts.DeployedEnforcer,
      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,
      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,
      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,
      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,
      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,
      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,
      IdEnforcer: contracts.IdEnforcer,
      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,
      NonceEnforcer: contracts.NonceEnforcer,
      TimestampEnforcer: contracts.TimestampEnforcer,
      ValueLteEnforcer: contracts.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: contracts.NativeTokenTransferAmountEnforcer,
      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,
      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,
      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,
      RedeemerEnforcer: contracts.RedeemerEnforcer,
      SpecificActionERC20TransferBatchEnforcer: contracts.SpecificActionERC20TransferBatchEnforcer,
      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,
      NativeTokenPeriodTransferEnforcer: contracts.NativeTokenPeriodTransferEnforcer,
      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,
      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,
      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,
      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,
      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer
    }
  };
}
async function deploySmartAccountsEnvironment(walletClient, publicClient, chain, deployedContracts = {}) {
  const deployContractCurried = async (name, contract, params = []) => {
    const existingAddress = deployedContracts[name];
    if (existingAddress) {
      return {
        address: existingAddress,
        name
      };
    }
    const deployedContract = await deployContract(
      walletClient,
      publicClient,
      chain,
      contract,
      params
    );
    const newDeployedContracts = { ...deployedContracts };
    newDeployedContracts[name] = deployedContract.address;
    Object.assign(deployedContracts, newDeployedContracts);
    return { ...deployedContract, name };
  };
  const standaloneContracts = {
    SimpleFactory: {
      abi: SimpleFactory2,
      bytecode: SimpleFactoryBytecode
    },
    AllowedCalldataEnforcer: {
      abi: AllowedCalldataEnforcer,
      bytecode: AllowedCalldataEnforcerBytecode
    },
    AllowedTargetsEnforcer: {
      abi: AllowedTargetsEnforcer,
      bytecode: AllowedTargetsEnforcerBytecode
    },
    AllowedMethodsEnforcer: {
      abi: AllowedMethodsEnforcer,
      bytecode: AllowedMethodsEnforcerBytecode
    },
    ArgsEqualityCheckEnforcer: {
      abi: ArgsEqualityCheckEnforcer,
      bytecode: ArgsEqualityCheckEnforcerBytecode
    },
    DeployedEnforcer: {
      abi: DeployedEnforcer,
      bytecode: DeployedEnforcerBytecode
    },
    TimestampEnforcer: {
      abi: TimestampEnforcer,
      bytecode: TimestampEnforcerBytecode
    },
    BlockNumberEnforcer: {
      abi: BlockNumberEnforcer,
      bytecode: BlockNumberEnforcerBytecode
    },
    LimitedCallsEnforcer: {
      abi: LimitedCallsEnforcer,
      bytecode: LimitedCallsEnforcerBytecode
    },
    ERC20BalanceChangeEnforcer: {
      abi: ERC20BalanceChangeEnforcer,
      bytecode: ERC20BalanceChangeEnforcerBytecode
    },
    ERC20TransferAmountEnforcer: {
      abi: ERC20TransferAmountEnforcer,
      bytecode: ERC20TransferAmountEnforcerBytecode
    },
    ERC20StreamingEnforcer: {
      abi: ERC20StreamingEnforcer,
      bytecode: ERC20StreamingEnforcerBytecode
    },
    ERC721BalanceChangeEnforcer: {
      abi: ERC721BalanceChangeEnforcer,
      bytecode: ERC721BalanceChangeEnforcerBytecode
    },
    ERC721TransferEnforcer: {
      abi: ERC721TransferEnforcer,
      bytecode: ERC721TransferEnforcerBytecode
    },
    ERC1155BalanceChangeEnforcer: {
      abi: ERC1155BalanceChangeEnforcer,
      bytecode: ERC1155BalanceChangeEnforcerBytecode
    },
    IdEnforcer: { abi: IdEnforcer, bytecode: IdEnforcerBytecode },
    NonceEnforcer: {
      abi: NonceEnforcer,
      bytecode: NonceEnforcerBytecode
    },
    ValueLteEnforcer: {
      abi: ValueLteEnforcer,
      bytecode: ValueLteEnforcerBytecode
    },
    NativeTokenTransferAmountEnforcer: {
      abi: NativeTokenTransferAmountEnforcer,
      bytecode: NativeTokenTransferAmountEnforcerBytecode
    },
    NativeBalanceChangeEnforcer: {
      abi: NativeBalanceChangeEnforcer,
      bytecode: NativeBalanceChangeEnforcerBytecode
    },
    NativeTokenStreamingEnforcer: {
      abi: NativeTokenStreamingEnforcer,
      bytecode: NativeTokenStreamingEnforcerBytecode
    },
    OwnershipTransferEnforcer: {
      abi: OwnershipTransferEnforcer,
      bytecode: OwnershipTransferEnforcerBytecode
    },
    RedeemerEnforcer: {
      abi: RedeemerEnforcer,
      bytecode: RedeemerEnforcerBytecode
    },
    SpecificActionERC20TransferBatchEnforcer: {
      abi: SpecificActionERC20TransferBatchEnforcer,
      bytecode: SpecificActionERC20TransferBatchEnforcerBytecode
    },
    ERC20PeriodTransferEnforcer: {
      abi: ERC20PeriodTransferEnforcer,
      bytecode: ERC20PeriodTransferEnforcerBytecode
    },
    NativeTokenPeriodTransferEnforcer: {
      abi: NativeTokenPeriodTransferEnforcer,
      bytecode: NativeTokenPeriodTransferEnforcerBytecode
    },
    ExactCalldataBatchEnforcer: {
      abi: ExactCalldataBatchEnforcer,
      bytecode: ExactCalldataBatchEnforcerBytecode
    },
    ExactCalldataEnforcer: {
      abi: ExactCalldataEnforcer,
      bytecode: ExactCalldataEnforcerBytecode
    },
    ExactExecutionEnforcer: {
      abi: ExactExecutionEnforcer,
      bytecode: ExactExecutionEnforcerBytecode
    },
    ExactExecutionBatchEnforcer: {
      abi: ExactExecutionBatchEnforcer,
      bytecode: ExactExecutionBatchEnforcerBytecode
    },
    MultiTokenPeriodEnforcer: {
      abi: MultiTokenPeriodEnforcer,
      bytecode: MultiTokenPeriodEnforcerBytecode
    }
  };
  for (const [name, contract] of Object.entries(standaloneContracts)) {
    await deployContractCurried(name, contract);
  }
  const delegationManager = await deployContractCurried(
    "DelegationManager",
    { abi: DelegationManager2, bytecode: DelegationManagerBytecode },
    [walletClient.account?.address]
  );
  await deployContractCurried(
    "NativeTokenPaymentEnforcer",
    {
      abi: NativeTokenPaymentEnforcer,
      bytecode: NativeTokenPaymentEnforcerBytecode
    },
    [delegationManager.address, deployedContracts.ArgsEqualityCheckEnforcer]
  );
  const entryPoint = await deployContractCurried("EntryPoint", {
    abi: EntryPoint,
    bytecode: EntryPointBytecode
  });
  const { address: sclRIP7212 } = await deployContract(
    walletClient,
    publicClient,
    chain,
    { abi: SCL_RIP7212, bytecode: SCLRIP7212Bytecode },
    []
  );
  const hybridDeleGatorWithLinkedLibrary = {
    abi: HybridDeleGator,
    bytecode: HybridDeleGatorBytecode.replace(
      /__\$b8f96b288d4d0429e38b8ed50fd423070f\$__/gu,
      sclRIP7212.slice(2)
    )
  };
  await deployContractCurried(
    "HybridDeleGatorImpl",
    hybridDeleGatorWithLinkedLibrary,
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried(
    "MultiSigDeleGatorImpl",
    {
      abi: MultiSigDeleGator,
      bytecode: MultiSigDeleGatorBytecode
    },
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried(
    "EIP7702StatelessDeleGatorImpl",
    {
      abi: EIP7702StatelessDeleGator,
      bytecode: EIP7702StatelessDeleGatorBytecode
    },
    [delegationManager.address, entryPoint.address]
  );
  return getSmartAccountsEnvironmentV1(deployedContracts);
}

// src/userOp.ts
import { concat, encodeAbiParameters, keccak256, pad, toHex } from "viem";
import { toPackedUserOperation } from "viem/account-abstraction";
import { signTypedData } from "viem/accounts";
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" },
    { name: "entryPoint", type: "address" }
  ]
};
var prepareSignUserOperationTypedData = ({
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const packedUserOp = toPackedUserOperation({
    ...userOperation,
    signature: "0x"
  });
  return {
    domain: {
      chainId,
      name,
      version,
      verifyingContract: address
    },
    types: SIGNABLE_USER_OP_TYPED_DATA,
    primaryType: "PackedUserOperation",
    message: { ...packedUserOp, entryPoint: entryPoint.address }
  };
};
var signUserOperation = async ({
  privateKey,
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const typedData = prepareSignUserOperationTypedData({
    userOperation,
    entryPoint,
    chainId,
    name,
    address,
    version
  });
  return signTypedData({
    privateKey,
    ...typedData
  });
};

export {
  redeemDelegations,
  PREFERRED_VERSION,
  overrideDeployedEnvironment,
  getSmartAccountsEnvironment,
  deploySmartAccountsEnvironment,
  SIGNABLE_USER_OP_TYPED_DATA,
  prepareSignUserOperationTypedData,
  signUserOperation
};
//# sourceMappingURL=chunk-5FLY3IPW.mjs.map