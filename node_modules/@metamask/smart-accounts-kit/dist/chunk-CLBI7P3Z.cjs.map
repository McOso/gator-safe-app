{"version":3,"sources":["/home/runner/work/smart-accounts-kit/smart-accounts-kit/packages/smart-accounts-kit/dist/chunk-CLBI7P3Z.cjs","../src/actions/index.ts","../src/actions/erc7710RedeemDelegationAction.ts","../src/actions/erc7715GetGrantedExecutionPermissionsAction.ts","../src/actions/erc7715GetSupportedExecutionPermissionsAction.ts","../src/actions/erc7715RequestExecutionPermissionsAction.ts","../src/actions/getCaveatAvailableAmount.ts","../src/actions/isValid7702Implementation.ts","../src/actions/signDelegation.ts","../src/actions/signUserOperation.ts"],"names":["BaseError"],"mappings":"AAAA;AACE;AACA;AACA;AACA;AACA;AACF,wDAA6B;AAC7B;AACE;AACA;AACF,wDAA6B;AAC7B;AACE;AACA;AACF,wDAA6B;AAC7B;AACE;AACA;AACA;AACA;AACA;AACF,wDAA6B;AAC7B;AACA;ACvBA,IAAA,gBAAA,EAAA,CAAA,CAAA;AAAA,wCAAA,eAAA,EAAA;AAAA,EAAA,qBAAA,EAAA,CAAA,EAAA,GAAA,qBAAA;AAAA,EAAA,qBAAA,EAAA,CAAA,EAAA,GAAA,qBAAA;AAAA,EAAA,oBAAA,EAAA,CAAA,EAAA,GAAA,oBAAA;AAAA,EAAA,sBAAA,EAAA,CAAA,EAAA,GAAA,sBAAA;AAAA,EAAA,6CAAA,EAAA,CAAA,EAAA,GAAA,6CAAA;AAAA,EAAA,wCAAA,EAAA,CAAA,EAAA,GAAA,wCAAA;AAAA,EAAA,8BAAA,EAAA,CAAA,EAAA,GAAA,2CAAA;AAAA,EAAA,0CAAA,EAAA,CAAA,EAAA,GAAA,0CAAA;AAAA,EAAA,mDAAA,EAAA,CAAA,EAAA,GAAA,mDAAA;AAAA,EAAA,8CAAA,EAAA,CAAA,EAAA,GAAA,8CAAA;AAAA,EAAA,gCAAA,EAAA,CAAA,EAAA,GAAA,6CAAA;AAAA,EAAA,yBAAA,EAAA,CAAA,EAAA,GAAA,yBAAA;AAAA,EAAA,2BAAA,EAAA,CAAA,EAAA,GAAA,wCAAA;AAAA,EAAA,cAAA,EAAA,CAAA,EAAA,GAAA,cAAA;AAAA,EAAA,qBAAA,EAAA,CAAA,EAAA,GAAA,qBAAA;AAAA,EAAA,iBAAA,EAAA,CAAA,EAAA,GAAA,iBAAA;AAAA,EAAA,wBAAA,EAAA,CAAA,EAAA,GAAA;AAAA,CAAA,CAAA;AD4CA;AACA;AE7CA,2DAAkC;AAYlC,4BAA2D;AAoC3D,MAAA,SAAsB,mCAAA,CAIpB,MAAA,EACA,IAAA,EACA;AACA,EAAA,GAAA,CAAI,CAAC,IAAA,CAAK,EAAA,EAAI;AACZ,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,EACF;AAEA,EAAA,MAAM,WAAA,EAAa;AAAA,IACjB,+CAAA;AAAgB,MACd,MAAA,EAAQ,IAAA,CAAK,EAAA;AAAA,MACb,KAAA,EAAO,IAAA,CAAK,KAAA;AAAA,MACZ,QAAA,EAAU,IAAA,CAAK;AAAA,IACjB,CAAC;AAAA,EACH,CAAA;AAEA,EAAA,MAAM,SAAA,EAAW,sCAAA;AAAmB,IAClC,GAAA,EAAK,iCAAA;AAAA,IACL,YAAA,EAAc,mBAAA;AAAA,IACd,IAAA,EAAM;AAAA,MACJ,CAAC,IAAA,CAAK,kBAAkB,CAAA;AAAA,MACxB,CAAA,wFAA4B,CAAA;AAAA,MAC5B,wDAAA,CAA0B,UAAU,CAAC;AAAA,IACvC;AAAA,EACF,CAAC,CAAA;AAED,EAAA,MAAM;AAAA,IACJ,KAAA,EAAO,MAAA;AAAA,IACP,kBAAA,EAAoB,mBAAA;AAAA,IACpB,iBAAA,EAAmB,kBAAA;AAAA,IACnB,GAAG;AAAA,EACL,EAAA,EAAI,IAAA;AAEJ,EAAA,MAAM,KAAA,EAAO,MAAM,MAAA,CAAO,eAAA,CAAgB;AAAA,IACxC,GAAG,IAAA;AAAA,IACH,EAAA,EAAI,IAAA,CAAK,iBAAA;AAAA,IACT,IAAA,EAAM;AAAA,EACR,CAAyC,CAAA;AAEzC,EAAA,OAAO,IAAA;AACT;AA2CA,MAAA,SAAsB,qCAAA,CAIpB,MAAA,EACA,UAAA,EAIA;AACA,EAAA,GAAA,CAAI,UAAA,CAAW,eAAA,EAAiB;AAC9B,IAAA,MAAM,EAAE,aAAa,EAAA,EAAI,UAAA;AAEzB,IAAA,MAAM,oBAAA,EAA4C,CAAC,CAAA;AAEnD,IAAA,MAAM,QAAA,kBAAU,YAAA,mBAAa,KAAA,6BAAO,IAAA;AAEpC,IAAA,GAAA,CAAI,CAAC,OAAA,EAAS;AACZ,MAAA,MAAM,IAAI,KAAA,CAAM,qBAAqB,CAAA;AAAA,IACvC;AAEA,IAAA,MAAM,EAAE,cAAc,EAAA,EAAI,2DAAA,OAAmC,CAAA;AAE7D,IAAA,MAAM,uBAAA,EAAyB,UAAA,CAAW,eAAA,CAAgB,MAAA;AAAA,MACxD,CAAC,eAAA,EAAA,GAAoB;AACnB,QAAA,GAAA,CAAI,CAAC,kCAAA,eAAe,CAAgB,OAAA,EAAS,aAAa,CAAA,EAAG;AAC3D,UAAA,MAAM,IAAI,KAAA;AAAA,YACR,CAAA,yBAAA,EAA4B,eAAA,CAAgB,OAAO,CAAA,gBAAA;AAAA,UACrD,CAAA;AAAA,QACF;AAGA,QAAA,MAAM,WAAA,EAAa,0BAAA;AAAO,UACxB,eAAA,CAAgB,OAAA;AAAA,UAChB,eAAA,CAAgB;AAAA,QAClB,CAAC,CAAA;AACD,QAAA,MAAM,YAAA,EAAc,mBAAA,CAAoB,UAAU,CAAA;AAElD,QAAA,mBAAA,CAAoB,UAAU,EAAA,EAAI,IAAA;AAClC,QAAA,OAAO,CAAC,WAAA;AAAA,MACV;AAAA,IACF,CAAA;AAEA,IAAA,MAAM,aAAA,EAAA,CACJ,MAAM,OAAA,CAAQ,GAAA;AAAA,MACZ,sBAAA,CAAuB,GAAA,CAAI,MAAA,CAAO,EAAE,OAAA,EAAS,YAAY,CAAA,EAAA,GAAM;AAC7D,QAAA,MAAM,WAAA,EAAa,MAAM,YAAA,CACtB,IAAA,CAAK;AAAA,UACJ,EAAA,EAAI,OAAA;AAAA,UACJ,IAAA,EAAM;AAAA,QACR,CAAC,CAAA,CACA,IAAA,CAAK,CAAA,EAAA,GAAM,KAAK,CAAA,CAChB,KAAA,CAAM,CAAA,EAAA,GAAM,IAAI,CAAA;AAEnB,QAAA,GAAA,CAAI,UAAA,EAAY;AACd,UAAA,OAAO,KAAA,CAAA;AAAA,QACT;AACA,QAAA,OAAO;AAAA,UACL,EAAA,EAAI,OAAA;AAAA,UACJ,KAAA,EAAO,EAAA;AAAA,UACP,IAAA,EAAM;AAAA,QACR,CAAA;AAAA,MACF,CAAC;AAAA,IACH,CAAA,CAAA,CACA,MAAA,CAAO,CAAC,IAAA,EAAA,GAA2B,KAAA,IAAS,KAAA,CAAS,CAAA;AAEvD,IAAA,UAAA,CAAW,MAAA,EAAQ;AAAA,MACjB,GAAI,YAAA;AAAA,MACJ,GAAG,UAAA,CAAW;AAAA,IAChB,CAAA;AAAA,EACF;AAEA,EAAA,OAAO,MAAA,CAAO,iBAAA;AAAA,IACZ;AAAA,EACF,CAAA;AACF;AF9EA;AACA;AGlHA,MAAA,SAAsB,2CAAA,CACpB,MAAA,EAC+C;AAC/C,EAAA,MAAM,OAAA,EAAS,MAAM,MAAA,CAAO,OAAA;AAAA,IAC1B;AAAA,MACE,MAAA,EAAQ,uCAAA;AAAA,MACR,MAAA,EAAQ,CAAC;AAAA,IACX,CAAA;AAAA,IACA,EAAE,UAAA,EAAY,EAAE;AAAA,EAClB,CAAA;AAEA,EAAA,GAAA,CAAI,CAAC,MAAA,EAAQ;AACX,IAAA,MAAM,IAAI,KAAA,CAAM,6CAA6C,CAAA;AAAA,EAC/D;AAEA,EAAA,OAAO,MAAA;AACT;AHgHA;AACA;AIxHA,MAAA,SAAsB,6CAAA,CACpB,MAAA,EACiD;AACjD,EAAA,MAAM,OAAA,EAAS,MAAM,MAAA,CAAO,OAAA;AAAA,IAC1B;AAAA,MACE,MAAA,EAAQ,yCAAA;AAAA,MACR,MAAA,EAAQ,CAAC;AAAA,IACX,CAAA;AAAA,IACA,EAAE,UAAA,EAAY,EAAE;AAAA,EAClB,CAAA;AAEA,EAAA,GAAA,CAAI,CAAC,MAAA,EAAQ;AACX,IAAA,MAAM,IAAI,KAAA,CAAM,+CAA+C,CAAA;AAAA,EACjE;AAEA,EAAA,OAAO,MAAA;AACT;AJsHA;AACA;AKxJA;AA2IA,MAAA,SAAsB,wCAAA,CACpB,MAAA,EACA,UAAA,EACgD;AAChD,EAAA,MAAM,2BAAA,EAA6B,UAAA,CAAW,GAAA,CAAI,wBAAwB,CAAA;AAE1E,EAAA,MAAM,OAAA,EAAS,MAAM,MAAA,CAAO,OAAA;AAAA,IAC1B;AAAA,MACE,MAAA,EAAQ,oCAAA;AAAA,MACR,MAAA,EAAQ;AAAA,IACV,CAAA;AAAA,IACA,EAAE,UAAA,EAAY,EAAE;AAAA,EAClB,CAAA;AAEA,EAAA,GAAA,CAAI,CAAC,MAAA,EAAQ;AACX,IAAA,MAAM,IAAI,KAAA,CAAM,6BAA6B,CAAA;AAAA,EAC/C;AAEA,EAAA,OAAO,MAAA;AACT;AASA,SAAS,wBAAA,CACP,UAAA,EACoC;AACpC,EAAA,MAAM,EAAE,OAAA,EAAS,IAAA,EAAM,MAAA,EAAQ,oBAAoB,EAAA,EAAI,UAAA;AAEvD,EAAA,MAAM,oBAAA,EAAsB,sBAAA;AAAA,IAC1B,UAAA,CAAW,UAAA,CAAW;AAAA,EACxB,CAAA;AAEA,EAAA,MAAM,MAAA,EAAgB,yCAAA,MAAgB,EAAA,EAClC;AAAA,IACE;AAAA,MACE,IAAA,EAAM,QAAA;AAAA,MACN,IAAA,EAAM;AAAA,QACJ,SAAA,EAAW;AAAA,MACb;AAAA,IACF;AAAA,EACF,EAAA,EACA,CAAC,CAAA;AAEL,EAAA,MAAM,eAAA,EAAiB;AAAA,IACrB,GAAI,KAAA,EAAO,EAAE,KAAK,EAAA,EAAI,CAAC;AAAA,EACzB,CAAA;AAEA,EAAA,OAAO;AAAA,IACL,GAAG,cAAA;AAAA,IACH,OAAA,EAAS,yBAAA,OAAa,CAAA;AAAA,IACtB,UAAA,EAAY,mBAAA,CAAoB;AAAA,MAC9B,UAAA,EAAY,UAAA,CAAW,UAAA;AAAA,MACvB;AAAA,IACF,CAAC,CAAA;AAAA,IACD,EAAA,EAAI,UAAA,CAAW,EAAA;AAAA,IACf;AAAA,EACF,CAAA;AACF;AAaA,SAAS,sBAAA,CAAuB,cAAA,EAA6C;AAC3E,EAAA,OAAA,CAAQ,cAAA,EAAgB;AAAA,IACtB,KAAK,qBAAA;AACH,MAAA,OAAO,CAAC,EAAE,UAAA,EAAY,oBAAoB,CAAA,EAAA,GACxC,iCAAA,CAAkC;AAAA,QAChC,UAAA;AAAA,QACA;AAAA,MACF,CAAC,CAAA;AAAA,IACL,KAAK,oBAAA;AACH,MAAA,OAAO,CAAC,EAAE,UAAA,EAAY,oBAAoB,CAAA,EAAA,GACxC,gCAAA,CAAiC;AAAA,QAC/B,UAAA;AAAA,QACA;AAAA,MACF,CAAC,CAAA;AAAA,IAEL,KAAK,uBAAA;AACH,MAAA,OAAO,CAAC,EAAE,UAAA,EAAY,oBAAoB,CAAA,EAAA,GACxC,mCAAA,CAAoC;AAAA,QAClC,UAAA;AAAA,QACA;AAAA,MACF,CAAC,CAAA;AAAA,IACL,KAAK,sBAAA;AACH,MAAA,OAAO,CAAC,EAAE,UAAA,EAAY,oBAAoB,CAAA,EAAA,GACxC,kCAAA,CAAmC;AAAA,QACjC,UAAA;AAAA,QACA;AAAA,MACF,CAAC,CAAA;AAAA,IACL,KAAK,wBAAA;AACH,MAAA,OAAO,CAAC,EAAE,UAAA,EAAY,oBAAoB,CAAA,EAAA,GACxC,oCAAA,CAAqC;AAAA,QACnC,UAAA;AAAA,QACA;AAAA,MACF,CAAC,CAAA;AAAA,IACL,OAAA;AACE,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,6BAAA,EAAgC,cAAc,CAAA,CAAA;AAClE,EAAA;AACF;AAU2C;AACzC,EAAA;AACA,EAAA;AAI8B;AACxB,EAAA;AACE,IAAA;AACJ,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACE,EAAA;AAEmB,EAAA;AACW,IAAA;AAC4B,MAAA;AAC5D,IAAA;AAC4B,IAAA;AACoB,MAAA;AAChD,IAAA;AAC4B,IAAA;AACC,MAAA;AAC7B,IAAA;AACyC,IAAA;AAC3C,EAAA;AAEO,EAAA;AACC,IAAA;AACA,IAAA;AAC2C,MAAA;AAC5C,MAAA;AACL,IAAA;AACA,IAAA;AACF,EAAA;AACF;AAY0C;AACxC,EAAA;AACA,EAAA;AAI6B;AACvB,EAAA;AACE,IAAA;AACJ,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACE,EAAA;AAEmB,EAAA;AACW,IAAA;AAC4B,MAAA;AAC5D,IAAA;AAC4B,IAAA;AACoB,MAAA;AAChD,IAAA;AAC4B,IAAA;AACC,MAAA;AAC7B,IAAA;AACyC,IAAA;AAC3C,EAAA;AAEO,EAAA;AACC,IAAA;AACA,IAAA;AACmD,MAAA;AACR,MAAA;AAC5C,MAAA;AACL,IAAA;AACA,IAAA;AACF,EAAA;AACF;AAU6C;AAC3C,EAAA;AACA,EAAA;AAIgC;AAC1B,EAAA;AAC2D,IAAA;AAC7D,EAAA;AAEmB,EAAA;AACO,IAAA;AACC,MAAA;AAC7B,IAAA;AACyC,IAAA;AAC3C,EAAA;AAEO,EAAA;AACC,IAAA;AACA,IAAA;AACmD,MAAA;AAClB,MAAA;AAClC,MAAA;AACL,IAAA;AACA,IAAA;AACF,EAAA;AACF;AAU4C;AAC1C,EAAA;AACA,EAAA;AAI+B;AACzB,EAAA;AACE,IAAA;AACJ,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACE,EAAA;AAEmB,EAAA;AACO,IAAA;AACC,MAAA;AAC7B,IAAA;AACyC,IAAA;AAC3C,EAAA;AAEO,EAAA;AACC,IAAA;AACA,IAAA;AACmD,MAAA;AACA,MAAA;AAClB,MAAA;AAClC,MAAA;AACL,IAAA;AACA,IAAA;AACF,EAAA;AACF;AAU8C;AAC5C,EAAA;AACA,EAAA;AAIiC;AAC3B,EAAA;AACkB,IAAA;AACpB,EAAA;AAES,EAAA;AAC8B,IAAA;AAC3C,EAAA;AACO,EAAA;AACC,IAAA;AACN,IAAA;AACA,IAAA;AACF,EAAA;AACF;AL/FqE;AACA;AM9UzC;AAC1B,EAAA;AACA,EAAA;AACA,EAAA;AAK4B;AACe,EAAA;AACqB,IAAA;AAChE,EAAA;AAEkC,EAAA;AAC0B,IAAA;AAC5D,EAAA;AAEgC,EAAA;AACpB,IAAA;AACqD,MAAA;AAC/D,IAAA;AACF,EAAA;AAE0B,EAAA;AAInB,EAAA;AACL,IAAA;AACA,IAAA;AACF,EAAA;AACF;AAQ8E;AACxC,EAAA;AACoB,IAAA;AACxD,EAAA;AAEmB,EAAA;AACrB;AAU4B;AAC1B,EAAA;AACA,EAAA;AAIU;AACsD,EAAA;AAC1C,EAAA;AACsC,IAAA;AAC5D,EAAA;AAEO,EAAA;AACT;AAYE;AAGqB,EAAA;AAEqC,EAAA;AACf,EAAA;AACzC,IAAA;AACA,IAAA;AACD,EAAA;AAEiE,EAAA;AAC7B,EAAA;AAChB,IAAA;AACnB,IAAA;AACA,IAAA;AACD,EAAA;AAE0D,EAAA;AACzD,IAAA;AACiB,IAAA;AACjB,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AACH;AAYE;AAGqB,EAAA;AACqC,EAAA;AACf,EAAA;AACzC,IAAA;AACA,IAAA;AACD,EAAA;AAEiE,EAAA;AAC7B,EAAA;AAChB,IAAA;AACnB,IAAA;AACA,IAAA;AACD,EAAA;AAEqD,EAAA;AACpD,IAAA;AACiB,IAAA;AACjB,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AACH;AAYE;AAGqB,EAAA;AACqC,EAAA;AACf,EAAA;AACzC,IAAA;AACA,IAAA;AACD,EAAA;AAEiE,EAAA;AACvB,EAAA;AACtB,IAAA;AACnB,IAAA;AACA,IAAA;AACD,EAAA;AAEuD,EAAA;AACtD,IAAA;AACiB,IAAA;AACjB,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AACH;AAWE;AAIqB,EAAA;AACqC,EAAA;AACf,EAAA;AACzC,IAAA;AACA,IAAA;AACD,EAAA;AAEiE,EAAA;AAC7B,EAAA;AAChB,IAAA;AACnB,IAAA;AACA,IAAA;AACD,EAAA;AAEgE,EAAA;AAC/D,IAAA;AACiB,IAAA;AACjB,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AACH;AAWE;AAIqB,EAAA;AACqC,EAAA;AACf,EAAA;AACzC,IAAA;AACA,IAAA;AACD,EAAA;AAEiE,EAAA;AAC7B,EAAA;AAChB,IAAA;AACnB,IAAA;AACA,IAAA;AACD,EAAA;AAE2D,EAAA;AAC1D,IAAA;AACiB,IAAA;AACjB,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AACH;AAWuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASiB,EAAA;AAC3B,IAAA;AACL,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU+B,EAAA;AACtB,IAAA;AACL,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUoC,EAAA;AAC3B,IAAA;AACL,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASE,EAAA;AAEO,IAAA;AACL,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAU+B,EAAA;AACtB,IAAA;AACL,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AACF;AN6MmE;AACA;AO9kBtC;AACP;AAKE;AAoB8C;AAC7C,EAAA;AAEhB,IAAA;AACT,EAAA;AAEkE,EAAA;AACzD,IAAA;AACT,EAAA;AAG+B,EAAA;AACT,EAAA;AACxB;AA6BgD;AAC9C,EAAA;AACA,EAAA;AACA,EAAA;AACwD;AACpD,EAAA;AAEiC,IAAA;AACxB,MAAA;AACV,IAAA;AAGoD,IAAA;AAG9B,IAAA;AACd,MAAA;AACT,IAAA;AAI8B,IAAA;AACD,IAAA;AACpB,MAAA;AACT,IAAA;AAE8D,IAAA;AACxD,EAAA;AAGC,IAAA;AACT,EAAA;AACF;AP8gBqE;AACA;AQ3mB3C;AACG;AAqDQ;AAC7B,EAAA;AAC2B,IAAA;AAC/B,IAAA;AACA,IAAA;AACA,IAAA;AACO,IAAA;AACG,IAAA;AAC4B,IAAA;AACpC,EAAA;AAEe,EAAA;AACG,IAAA;AACtB,EAAA;AAEyC,EAAA;AAEQ,EAAA;AAC/C,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AAE2B,EAAA;AAC1B,IAAA;AACG,IAAA;AACJ,EAAA;AACH;AAcwC;AAQhC,EAAA;AAMqB,IAAA;AAGZ,MAAA;AACkB,QAAA;AACX,UAAA;AACR,YAAA;AACF,UAAA;AACF,QAAA;AACoB,QAAA;AACnB,MAAA;AACF,MAAA;AACJ,IAAA;AACL,EAAA;AACF;AR0hBqE;AACA;ASzpB3C;AACG;AA0DW;AAChC,EAAA;AAC2B,IAAA;AAC/B,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACU,IAAA;AACR,EAAA;AAEe,EAAA;AACG,IAAA;AACtB,EAAA;AAEyC,EAAA;AAEW,EAAA;AAClD,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AAE2B,EAAA;AAC1B,IAAA;AACG,IAAA;AACJ,EAAA;AACH;AAc2C;AAQnC,EAAA;AAMgB,IAAA;AAGP,MAAA;AACkB,QAAA;AACXA,UAAAA;AACR,YAAA;AACF,UAAA;AACF,QAAA;AACoB,QAAA;AACnB,MAAA;AACF,MAAA;AACJ,IAAA;AACL,EAAA;AACF;ATmkBqE;AACA;ACvoBJ;AAG1D,EAAA;AACI,IAAA;AACL,MAAA;AACA,MAAA;AACF,IAAA;AACF,EAAA;AAC8C,EAAA;AACrC,IAAA;AACL,MAAA;AACF,IAAA;AACF,EAAA;AAC4C,EAAA;AACnC,IAAA;AACL,MAAA;AACF,IAAA;AACF,EAAA;AACF;AAqBqE;AAG9D,EAAA;AACP;AAEgE;AAGzD,EAAA;AACP;AD8mBqE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/smart-accounts-kit/smart-accounts-kit/packages/smart-accounts-kit/dist/chunk-CLBI7P3Z.cjs","sourcesContent":[null,"import type { Client, WalletClient } from 'viem';\nimport type { BundlerClient } from 'viem/account-abstraction';\n\nimport type {\n  SendTransactionWithDelegationParameters,\n  SendUserOperationWithDelegationParameters,\n} from './erc7710RedeemDelegationAction';\nimport {\n  sendTransactionWithDelegationAction,\n  sendUserOperationWithDelegationAction,\n} from './erc7710RedeemDelegationAction';\nimport { erc7715GetGrantedExecutionPermissionsAction } from './erc7715GetGrantedExecutionPermissionsAction';\nimport { erc7715GetSupportedExecutionPermissionsAction } from './erc7715GetSupportedExecutionPermissionsAction';\nimport { erc7715RequestExecutionPermissionsAction } from './erc7715RequestExecutionPermissionsAction';\nimport type {\n  MetaMaskExtensionClient,\n  RequestExecutionPermissionsParameters,\n} from './erc7715RequestExecutionPermissionsAction';\n\nexport {\n  // Individual action functions\n  getErc20PeriodTransferEnforcerAvailableAmount,\n  getErc20StreamingEnforcerAvailableAmount,\n  getMultiTokenPeriodEnforcerAvailableAmount,\n  getNativeTokenPeriodTransferEnforcerAvailableAmount,\n  getNativeTokenStreamingEnforcerAvailableAmount,\n  // Action builder\n  caveatEnforcerActions,\n  // Parameter types\n  type CaveatEnforcerParams,\n  // Result types\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\nexport { isValid7702Implementation } from './isValid7702Implementation';\n\n// Signing actions\nexport {\n  signDelegation,\n  signDelegationActions,\n  type SignDelegationParameters,\n  type SignDelegationReturnType,\n} from './signDelegation';\n\nexport {\n  signUserOperation,\n  signUserOperationActions,\n  type SignUserOperationParameters,\n  type SignUserOperationReturnType,\n} from './signUserOperation';\n\nexport {\n  erc7715RequestExecutionPermissionsAction as requestExecutionPermissions,\n  type MetaMaskExtensionClient,\n  type MetaMaskExtensionSchema,\n  type PermissionRequestParameter,\n  type RequestExecutionPermissionsParameters,\n  type RequestExecutionPermissionsReturnType,\n} from './erc7715RequestExecutionPermissionsAction';\n\nexport { erc7715GetSupportedExecutionPermissionsAction as getSupportedExecutionPermissions } from './erc7715GetSupportedExecutionPermissionsAction';\n\nexport { erc7715GetGrantedExecutionPermissionsAction as getGrantedExecutionPermissions } from './erc7715GetGrantedExecutionPermissionsAction';\n\nexport {\n  type GetSupportedExecutionPermissionsResult,\n  type GetGrantedExecutionPermissionsResult,\n  type SupportedPermissionInfo,\n} from './erc7715Types';\n\nexport type { DelegatedCall } from './erc7710RedeemDelegationAction';\n\nexport const erc7715ProviderActions = () => (client: Client) => ({\n  requestExecutionPermissions: async (\n    parameters: RequestExecutionPermissionsParameters,\n  ) => {\n    return erc7715RequestExecutionPermissionsAction(\n      client as MetaMaskExtensionClient,\n      parameters,\n    );\n  },\n  getSupportedExecutionPermissions: async () => {\n    return erc7715GetSupportedExecutionPermissionsAction(\n      client as MetaMaskExtensionClient,\n    );\n  },\n  getGrantedExecutionPermissions: async () => {\n    return erc7715GetGrantedExecutionPermissionsAction(\n      client as MetaMaskExtensionClient,\n    );\n  },\n});\n\n/**\n * Type for a viem Client extended with ERC-7715 provider actions.\n * Use this to type variables that will be assigned an extended client later.\n *\n * @example\n * ```typescript\n * let client: Erc7715Client | null = null;\n *\n * function setupClient() {\n *   client = createWalletClient({\n *     chain: sepolia,\n *     transport: custom(window.ethereum),\n *   }).extend(erc7715ProviderActions());\n * }\n * ```\n */\nexport type Erc7715Client = Client &\n  ReturnType<ReturnType<typeof erc7715ProviderActions>>;\n\nexport const erc7710WalletActions = () => (client: WalletClient) => ({\n  sendTransactionWithDelegation: async (\n    args: SendTransactionWithDelegationParameters,\n  ) => sendTransactionWithDelegationAction(client, args),\n});\n\nexport const erc7710BundlerActions = () => (client: Client) => ({\n  sendUserOperationWithDelegation: async (\n    args: SendUserOperationWithDelegationParameters,\n  ) => sendUserOperationWithDelegationAction(client as BundlerClient, args),\n});\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type {\n  Account,\n  Chain,\n  Hex,\n  OneOf,\n  PublicClient,\n  SendTransactionParameters,\n  SendTransactionRequest,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { concat, encodeFunctionData, isAddressEqual } from 'viem';\nimport type {\n  BundlerClient,\n  SendUserOperationParameters,\n  SmartAccount,\n} from 'viem/account-abstraction';\n\nimport {\n  createExecution,\n  encodeExecutionCalldatas,\n  ExecutionMode,\n} from '../executions';\nimport { getSmartAccountsEnvironment } from '../smartAccountsEnvironment';\nimport type { Call } from '../types';\n\nexport type DelegatedCall = Call &\n  OneOf<{ permissionsContext: Hex; delegationManager: Hex } | object>;\n\nexport type SendTransactionWithDelegationParameters<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n  TChainOverride extends Chain | undefined = Chain | undefined,\n  TRequest extends SendTransactionRequest<TChain, TChainOverride> =\n    SendTransactionRequest<TChain, TChainOverride>,\n> = SendTransactionParameters<TChain, TAccount, TChainOverride, TRequest> & {\n  permissionsContext: Hex;\n  delegationManager: Hex;\n};\n\n/**\n * Sends a transaction using delegation to execute operations on behalf of another account.\n *\n * @param client - The wallet client to use for sending the transaction.\n * @param args - Transaction parameters with delegation details.\n * @returns Transaction hash of the executed transaction.\n */\nexport async function sendTransactionWithDelegationAction<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: WalletClient<Transport, TChain, TAccount>,\n  args: SendTransactionWithDelegationParameters<TChain, TAccount>,\n) {\n  if (!args.to) {\n    throw new Error(\n      '`to` is required. `sendTransactionWithDelegation` cannot be used to deploy contracts.',\n    );\n  }\n\n  const executions = [\n    createExecution({\n      target: args.to,\n      value: args.value,\n      callData: args.data,\n    }),\n  ];\n\n  const calldata = encodeFunctionData({\n    abi: DelegationManager,\n    functionName: 'redeemDelegations',\n    args: [\n      [args.permissionsContext],\n      [ExecutionMode.SingleDefault],\n      encodeExecutionCalldatas([executions]),\n    ],\n  });\n\n  const {\n    value: _value,\n    permissionsContext: _permissionsContext,\n    delegationManager: _delegationManager,\n    ...rest\n  } = args;\n\n  const hash = await client.sendTransaction({\n    ...rest,\n    to: args.delegationManager,\n    data: calldata,\n  } as unknown as SendTransactionParameters);\n\n  return hash;\n}\n\nexport type SendUserOperationWithDelegationParameters<\n  TAccount extends SmartAccount | undefined = SmartAccount | undefined,\n  TAccountOverride extends SmartAccount | undefined = SmartAccount | undefined,\n> = SendUserOperationParameters<TAccount, TAccountOverride, DelegatedCall[]> & {\n  accountMetadata?: { factory: Hex; factoryData: Hex }[];\n  calls: DelegatedCall[];\n  publicClient: PublicClient<Transport, Chain>;\n};\n\n/**\n * Broadcasts a User Operation with delegation to the Bundler.\n *\n * @param client - Client to use for sending the user operation.\n * @param parameters - Parameters for the user operation with delegation.\n * @returns The User Operation hash of the broadcasted operation.\n * @example\n * import { createBundlerClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const userOpHash = await sendUserOperationWithDelegationAction(bundlerClient, {\n *   account: bobSmartAccount,\n *   calls: [\n *     {\n *       to: aliceCounterContractAddress,\n *       data: encodeFunctionData({\n *         abi: CounterMetadata.abi,\n *         functionName: 'increment',\n *       }),\n *       value: 0n,\n *       permissionsContext: '0x...',\n *       delegationManager: '0x...',\n *     },\n *   ],\n *   accountMetadata: [{ factory: '0x...', factoryData: '0x...' }], // Optional: for deploying accounts\n * })\n */\nexport async function sendUserOperationWithDelegationAction<\n  TAccount extends SmartAccount | undefined,\n  TAccountOverride extends SmartAccount | undefined = undefined,\n>(\n  client: BundlerClient<Transport, Chain | undefined, TAccount>,\n  parameters: SendUserOperationWithDelegationParameters<\n    TAccount,\n    TAccountOverride\n  >,\n) {\n  if (parameters.accountMetadata) {\n    const { publicClient } = parameters;\n\n    const includedAccountKeys: Record<Hex, boolean> = {};\n\n    const chainId = publicClient.chain?.id;\n\n    if (!chainId) {\n      throw new Error('Chain ID is not set');\n    }\n\n    const { SimpleFactory } = getSmartAccountsEnvironment(chainId);\n\n    const uniqueAccountMetadatas = parameters.accountMetadata.filter(\n      (accountMetadata) => {\n        if (!isAddressEqual(accountMetadata.factory, SimpleFactory)) {\n          throw new Error(\n            `Invalid accountMetadata: ${accountMetadata.factory} is not allowed.`,\n          );\n        }\n\n        // ensure that factory calls are not duplicated\n        const accountKey = concat([\n          accountMetadata.factory,\n          accountMetadata.factoryData,\n        ]);\n        const isDuplicate = includedAccountKeys[accountKey];\n\n        includedAccountKeys[accountKey] = true;\n        return !isDuplicate;\n      },\n    );\n\n    const factoryCalls = (\n      await Promise.all(\n        uniqueAccountMetadatas.map(async ({ factory, factoryData }) => {\n          const isDeployed = await publicClient\n            .call({\n              to: factory,\n              data: factoryData,\n            })\n            .then(() => false)\n            .catch(() => true);\n\n          if (isDeployed) {\n            return undefined;\n          }\n          return {\n            to: factory,\n            value: 0n,\n            data: factoryData,\n          };\n        }),\n      )\n    ).filter((call: Call | undefined) => call !== undefined) as Call[];\n\n    parameters.calls = [\n      ...(factoryCalls as DelegatedCall[]),\n      ...parameters.calls,\n    ];\n  }\n\n  return client.sendUserOperation(\n    parameters as unknown as SendUserOperationParameters,\n  );\n}\n","import type {\n  GetGrantedExecutionPermissionsResult,\n  MetaMaskExtensionClient,\n} from './erc7715Types';\n\n/**\n * Retrieves all previously granted execution permissions from the wallet according to EIP-7715 specification.\n *\n * @param client - The client to use for the request.\n * @returns A promise that resolves to an array of granted permission responses.\n * @description\n * This function queries the wallet for all granted permissions that are not yet revoked.\n * Each permission response includes the chain ID, address, signer, permission details,\n * context, and dependency information.\n * @example\n * ```typescript\n * const grantedPermissions = await erc7715GetGrantedExecutionPermissionsAction(client);\n * // Returns an array of PermissionResponse objects\n * ```\n */\nexport async function erc7715GetGrantedExecutionPermissionsAction(\n  client: MetaMaskExtensionClient,\n): Promise<GetGrantedExecutionPermissionsResult> {\n  const result = await client.request(\n    {\n      method: 'wallet_getGrantedExecutionPermissions',\n      params: [],\n    },\n    { retryCount: 0 },\n  );\n\n  if (!result) {\n    throw new Error('Failed to get granted execution permissions');\n  }\n\n  return result;\n}\n","import type {\n  GetSupportedExecutionPermissionsResult,\n  MetaMaskExtensionClient,\n} from './erc7715Types';\n\n/**\n * Retrieves the supported execution permission types from the wallet according to EIP-7715 specification.\n *\n * @param client - The client to use for the request.\n * @returns A promise that resolves to a record of supported permission types with their chain IDs and rule types.\n * @description\n * This function queries the wallet for the permission types it supports.\n * The result is keyed by permission type and includes the supported chain IDs and rule types.\n * @example\n * ```typescript\n * const supported = await erc7715GetSupportedExecutionPermissionsAction(client);\n * // Returns:\n * // {\n * //   \"native-token-allowance\": {\n * //     \"chainIds\": [\"0x1\", \"0x89\"],\n * //     \"ruleTypes\": [\"expiry\"]\n * //   },\n * //   \"erc20-token-allowance\": {\n * //     \"chainIds\": [\"0x1\"],\n * //     \"ruleTypes\": []\n * //   }\n * // }\n * ```\n */\nexport async function erc7715GetSupportedExecutionPermissionsAction(\n  client: MetaMaskExtensionClient,\n): Promise<GetSupportedExecutionPermissionsResult> {\n  const result = await client.request(\n    {\n      method: 'wallet_getSupportedExecutionPermissions',\n      params: [],\n    },\n    { retryCount: 0 },\n  );\n\n  if (!result) {\n    throw new Error('Failed to get supported execution permissions');\n  }\n\n  return result;\n}\n","import type {\n  Erc20TokenPeriodicPermission,\n  Erc20TokenStreamPermission,\n  Erc20TokenRevocationPermission,\n  NativeTokenPeriodicPermission,\n  NativeTokenStreamPermission,\n  PermissionRequest,\n  PermissionResponse,\n  PermissionTypes,\n  Rule,\n  Hex,\n} from '@metamask/7715-permission-types';\nimport { toHex } from 'viem';\nimport type { Address } from 'viem';\n\nimport { isDefined, toHexOrThrow } from '../utils';\nimport type { MetaMaskExtensionClient } from './erc7715Types';\n\nexport type {\n  GetGrantedExecutionPermissionsResult,\n  GetSupportedExecutionPermissionsResult,\n  MetaMaskExtensionClient,\n  MetaMaskExtensionSchema,\n  SupportedPermissionInfo,\n} from './erc7715Types';\n\ntype PermissionParameter = {\n  type: string;\n  data: Record<string, unknown>;\n};\n\n/**\n * Represents a native token stream permission.\n * This allows for continuous token streaming with defined parameters.\n */\nexport type NativeTokenStreamPermissionParameter = PermissionParameter & {\n  type: 'native-token-stream';\n  data: {\n    amountPerSecond: bigint;\n    initialAmount?: bigint;\n    maxAmount?: bigint;\n    startTime?: number;\n    justification?: string;\n  };\n};\n\n/**\n * Represents an ERC-20 token stream permission.\n * This allows for continuous ERC-20 token streaming with defined parameters.\n */\nexport type Erc20TokenStreamPermissionParameter = PermissionParameter & {\n  type: 'erc20-token-stream';\n  data: {\n    tokenAddress: Address;\n    amountPerSecond: bigint;\n    initialAmount?: bigint;\n    maxAmount?: bigint;\n    startTime?: number;\n    justification?: string;\n  };\n};\n\n/**\n * Represents a native token periodic permission.\n * This allows for periodic native token transfers with defined parameters.\n */\nexport type NativeTokenPeriodicPermissionParameter = PermissionParameter & {\n  type: 'native-token-periodic';\n  data: {\n    periodAmount: bigint;\n    periodDuration: number;\n    startTime?: number;\n    justification?: string;\n  };\n};\n\n/**\n * Represents an ERC-20 token periodic permission.\n * This allows for periodic ERC-20 token transfers with defined parameters.\n */\nexport type Erc20TokenPeriodicPermissionParameter = PermissionParameter & {\n  type: 'erc20-token-periodic';\n  data: {\n    tokenAddress: Address;\n    periodAmount: bigint;\n    periodDuration: number;\n    startTime?: number;\n    justification?: string;\n  };\n};\n\n/**\n * Represents an ERC-20 token revocation permission.\n * This allows for revoking an ERC-20 token allowance.\n */\nexport type Erc20TokenRevocationPermissionParameter = PermissionParameter & {\n  type: 'erc20-token-revocation';\n  data: {\n    justification?: string;\n  };\n};\n\nexport type SupportedPermissionParams =\n  | NativeTokenStreamPermissionParameter\n  | Erc20TokenStreamPermissionParameter\n  | NativeTokenPeriodicPermissionParameter\n  | Erc20TokenPeriodicPermissionParameter\n  | Erc20TokenRevocationPermissionParameter;\n\n/**\n * Represents a single permission request.\n */\nexport type PermissionRequestParameter = {\n  chainId: number;\n  // The permission to grant to the user.\n  permission: SupportedPermissionParams;\n  // Whether the caller allows the permission to be adjusted.\n  isAdjustmentAllowed: boolean;\n  // Account to assign the permission to.\n  to: Hex;\n  // address from which the permission should be granted.\n  from?: Address | undefined | null;\n  // Timestamp (in seconds) that specifies the time by which this permission MUST expire.\n  expiry?: number | undefined | null;\n};\n\n/**\n * Parameters for the RequestExecutionPermissions action.\n *\n * @template Signer - The type of the signer, either an Address or Account.\n */\nexport type RequestExecutionPermissionsParameters =\n  PermissionRequestParameter[];\n\n/**\n * Return type for the request execution permissions action.\n */\nexport type RequestExecutionPermissionsReturnType =\n  PermissionResponse<PermissionTypes>[];\n\n/**\n * Grants permissions according to EIP-7715 specification.\n *\n * @template Signer - The type of the signer, either an Address or Account.\n * @param client - The client to use for the request.\n * @param parameters - The permissions requests to grant.\n * @returns A promise that resolves to the permission responses.\n * @description\n * This function formats the permissions requests and invokes the wallet method to grant permissions.\n * It will throw an error if the permissions could not be granted.\n */\nexport async function erc7715RequestExecutionPermissionsAction(\n  client: MetaMaskExtensionClient,\n  parameters: RequestExecutionPermissionsParameters,\n): Promise<RequestExecutionPermissionsReturnType> {\n  const formattedPermissionRequest = parameters.map(formatPermissionsRequest);\n\n  const result = await client.request(\n    {\n      method: 'wallet_requestExecutionPermissions',\n      params: formattedPermissionRequest,\n    },\n    { retryCount: 0 },\n  );\n\n  if (!result) {\n    throw new Error('Failed to grant permissions');\n  }\n\n  return result;\n}\n\n/**\n * Formats a permissions request for submission to the wallet.\n *\n * @param parameters - The permissions request to format.\n * @returns The formatted permissions request.\n * @internal\n */\nfunction formatPermissionsRequest(\n  parameters: PermissionRequestParameter,\n): PermissionRequest<PermissionTypes> {\n  const { chainId, from, expiry, isAdjustmentAllowed } = parameters;\n\n  const permissionFormatter = getPermissionFormatter(\n    parameters.permission.type,\n  );\n\n  const rules: Rule[] = isDefined(expiry)\n    ? [\n        {\n          type: 'expiry',\n          data: {\n            timestamp: expiry,\n          },\n        },\n      ]\n    : [];\n\n  const optionalFields = {\n    ...(from ? { from } : {}),\n  };\n\n  return {\n    ...optionalFields,\n    chainId: toHex(chainId),\n    permission: permissionFormatter({\n      permission: parameters.permission,\n      isAdjustmentAllowed,\n    }),\n    to: parameters.to,\n    rules,\n  };\n}\n\ntype PermissionFormatter = (params: {\n  permission: PermissionParameter;\n  isAdjustmentAllowed: boolean;\n}) => PermissionTypes;\n\n/**\n * Gets the appropriate formatter function for a specific permission type.\n *\n * @param permissionType - The type of permission to format.\n * @returns A formatter function for the specified permission type.\n */\nfunction getPermissionFormatter(permissionType: string): PermissionFormatter {\n  switch (permissionType) {\n    case 'native-token-stream':\n      return ({ permission, isAdjustmentAllowed }) =>\n        formatNativeTokenStreamPermission({\n          permission: permission as NativeTokenStreamPermissionParameter,\n          isAdjustmentAllowed,\n        });\n    case 'erc20-token-stream':\n      return ({ permission, isAdjustmentAllowed }) =>\n        formatErc20TokenStreamPermission({\n          permission: permission as Erc20TokenStreamPermissionParameter,\n          isAdjustmentAllowed,\n        });\n\n    case 'native-token-periodic':\n      return ({ permission, isAdjustmentAllowed }) =>\n        formatNativeTokenPeriodicPermission({\n          permission: permission as NativeTokenPeriodicPermissionParameter,\n          isAdjustmentAllowed,\n        });\n    case 'erc20-token-periodic':\n      return ({ permission, isAdjustmentAllowed }) =>\n        formatErc20TokenPeriodicPermission({\n          permission: permission as Erc20TokenPeriodicPermissionParameter,\n          isAdjustmentAllowed,\n        });\n    case 'erc20-token-revocation':\n      return ({ permission, isAdjustmentAllowed }) =>\n        formatErc20TokenRevocationPermission({\n          permission: permission as Erc20TokenRevocationPermissionParameter,\n          isAdjustmentAllowed,\n        });\n    default:\n      throw new Error(`Unsupported permission type: ${permissionType}`);\n  }\n}\n\n/**\n * Formats a native token stream permission for the wallet.\n *\n * @param permission - The native token stream permission to format.\n * @param permission.permission - The native token stream permission to format.\n * @param permission.isAdjustmentAllowed - Whether the permission is allowed to be adjusted.\n * @returns The formatted permission object.\n */\nfunction formatNativeTokenStreamPermission({\n  permission,\n  isAdjustmentAllowed,\n}: {\n  permission: NativeTokenStreamPermissionParameter;\n  isAdjustmentAllowed: boolean;\n}): NativeTokenStreamPermission {\n  const {\n    data: {\n      initialAmount,\n      justification,\n      maxAmount,\n      startTime,\n      amountPerSecond,\n    },\n  } = permission;\n\n  const optionalFields = {\n    ...(isDefined(initialAmount) && {\n      initialAmount: toHexOrThrow(initialAmount, 'initialAmount'),\n    }),\n    ...(isDefined(maxAmount) && {\n      maxAmount: toHexOrThrow(maxAmount, 'maxAmount'),\n    }),\n    ...(isDefined(startTime) && {\n      startTime: Number(startTime),\n    }),\n    ...(justification ? { justification } : {}),\n  };\n\n  return {\n    type: 'native-token-stream',\n    data: {\n      amountPerSecond: toHexOrThrow(amountPerSecond, 'amountPerSecond'),\n      ...optionalFields,\n    },\n    isAdjustmentAllowed,\n  };\n}\n\n/**\n * Formats an ERC-20 token stream permission parameter into the required\n * Erc20TokenStreamPermission object, converting numeric values to hex strings\n * and including only specified optional fields.\n *\n * @param params - The parameters for formatting the ERC-20 token stream permission.\n * @param params.permission - The ERC-20 token stream permission parameter to format.\n * @param params.isAdjustmentAllowed - Whether adjustment of the stream is allowed.\n * @returns The formatted Erc20TokenStreamPermission object.\n */\nfunction formatErc20TokenStreamPermission({\n  permission,\n  isAdjustmentAllowed,\n}: {\n  permission: Erc20TokenStreamPermissionParameter;\n  isAdjustmentAllowed: boolean;\n}): Erc20TokenStreamPermission {\n  const {\n    data: {\n      tokenAddress,\n      amountPerSecond,\n      initialAmount,\n      startTime,\n      maxAmount,\n      justification,\n    },\n  } = permission;\n\n  const optionalFields = {\n    ...(isDefined(initialAmount) && {\n      initialAmount: toHexOrThrow(initialAmount, 'initialAmount'),\n    }),\n    ...(isDefined(maxAmount) && {\n      maxAmount: toHexOrThrow(maxAmount, 'maxAmount'),\n    }),\n    ...(isDefined(startTime) && {\n      startTime: Number(startTime),\n    }),\n    ...(justification ? { justification } : {}),\n  };\n\n  return {\n    type: 'erc20-token-stream',\n    data: {\n      tokenAddress: toHexOrThrow(tokenAddress, 'tokenAddress'),\n      amountPerSecond: toHexOrThrow(amountPerSecond, 'amountPerSecond'),\n      ...optionalFields,\n    },\n    isAdjustmentAllowed,\n  };\n}\n\n/**\n * Formats a native token periodic permission for submission to the wallet.\n *\n * @param params - The parameters for formatting the native token periodic permission.\n * @param params.permission - The native token periodic permission parameter to format.\n * @param params.isAdjustmentAllowed - Whether the permission is allowed to be adjusted.\n * @returns The formatted NativeTokenPeriodicPermission object.\n */\nfunction formatNativeTokenPeriodicPermission({\n  permission,\n  isAdjustmentAllowed,\n}: {\n  permission: NativeTokenPeriodicPermissionParameter;\n  isAdjustmentAllowed: boolean;\n}): NativeTokenPeriodicPermission {\n  const {\n    data: { periodAmount, periodDuration, startTime, justification },\n  } = permission;\n\n  const optionalFields = {\n    ...(isDefined(startTime) && {\n      startTime: Number(startTime),\n    }),\n    ...(justification ? { justification } : {}),\n  };\n\n  return {\n    type: 'native-token-periodic',\n    data: {\n      periodAmount: toHexOrThrow(periodAmount, 'periodAmount'),\n      periodDuration: Number(periodDuration),\n      ...optionalFields,\n    },\n    isAdjustmentAllowed,\n  };\n}\n\n/**\n * Formats an ERC20 token periodic permission for submission to the wallet.\n *\n * @param params - The parameters for formatting the ERC20 token periodic permission.\n * @param params.permission - The ERC20 token periodic permission parameter to format.\n * @param params.isAdjustmentAllowed - Whether the permission is allowed to be adjusted.\n * @returns The formatted Erc20TokenPeriodicPermission object.\n */\nfunction formatErc20TokenPeriodicPermission({\n  permission,\n  isAdjustmentAllowed,\n}: {\n  permission: Erc20TokenPeriodicPermissionParameter;\n  isAdjustmentAllowed: boolean;\n}): Erc20TokenPeriodicPermission {\n  const {\n    data: {\n      tokenAddress,\n      periodAmount,\n      periodDuration,\n      startTime,\n      justification,\n    },\n  } = permission;\n\n  const optionalFields = {\n    ...(isDefined(startTime) && {\n      startTime: Number(startTime),\n    }),\n    ...(justification ? { justification } : {}),\n  };\n\n  return {\n    type: 'erc20-token-periodic',\n    data: {\n      tokenAddress: toHexOrThrow(tokenAddress, 'tokenAddress'),\n      periodAmount: toHexOrThrow(periodAmount, 'periodAmount'),\n      periodDuration: Number(periodDuration),\n      ...optionalFields,\n    },\n    isAdjustmentAllowed,\n  };\n}\n\n/**\n * Formats an ERC-20 token revocation permission for submission to the wallet.\n *\n * @param params - The parameters for formatting the ERC-20 token revocation permission.\n * @param params.permission - The ERC-20 token revocation permission parameter to format.\n * @param params.isAdjustmentAllowed - Whether the permission is allowed to be adjusted.\n * @returns The formatted Erc20TokenRevocationPermission object.\n */\nfunction formatErc20TokenRevocationPermission({\n  permission,\n  isAdjustmentAllowed,\n}: {\n  permission: Erc20TokenRevocationPermissionParameter;\n  isAdjustmentAllowed: boolean;\n}): Erc20TokenRevocationPermission {\n  const {\n    data: { justification },\n  } = permission;\n\n  const data = {\n    ...(justification ? { justification } : {}),\n  };\n  return {\n    type: 'erc20-token-revocation',\n    data,\n    isAdjustmentAllowed,\n  };\n}\n","import type { Address, Hex, Client } from 'viem';\n\nimport { getDelegationHashOffchain } from '../delegation';\nimport * as ERC20PeriodTransferEnforcer from '../DelegationFramework/ERC20PeriodTransferEnforcer';\nimport * as ERC20StreamingEnforcer from '../DelegationFramework/ERC20StreamingEnforcer';\nimport * as MultiTokenPeriodEnforcer from '../DelegationFramework/MultiTokenPeriodEnforcer';\nimport * as NativeTokenPeriodTransferEnforcer from '../DelegationFramework/NativeTokenPeriodTransferEnforcer';\nimport * as NativeTokenStreamingEnforcer from '../DelegationFramework/NativeTokenStreamingEnforcer';\nimport type { SmartAccountsEnvironment, Delegation } from '../types';\n\n/**\n * Parameters for all caveat enforcer actions.\n */\nexport type CaveatEnforcerParams = {\n  delegation: Delegation;\n};\n\n/**\n * Return type for period-based transfer enforcers\n */\nexport type PeriodTransferResult = {\n  availableAmount: bigint;\n  isNewPeriod: boolean;\n  currentPeriod: bigint;\n};\n\n/**\n * Return type for streaming enforcers\n */\nexport type StreamingResult = {\n  availableAmount: bigint;\n};\n\n/**\n * Finds a caveat that matches the specified enforcer address.\n *\n * @param config - The configuration object.\n * @param config.delegation - The delegation to search.\n * @param config.enforcerAddress - The enforcer address to match.\n * @param config.enforcerName - The name of the enforcer.\n * @returns The matching caveat.\n * @throws Error if no matching caveat is found.\n * @throws Error if multiple matching caveats are found.\n */\nfunction findMatchingCaveat({\n  delegation,\n  enforcerAddress,\n  enforcerName,\n}: {\n  delegation: Delegation;\n  enforcerAddress: Address;\n  enforcerName: keyof SmartAccountsEnvironment['caveatEnforcers'];\n}): { terms: Hex; args: Hex } {\n  const matchingCaveats = delegation.caveats.filter(\n    (caveat) => caveat.enforcer.toLowerCase() === enforcerAddress.toLowerCase(),\n  );\n\n  if (matchingCaveats.length === 0) {\n    throw new Error(`No caveat found with enforcer matching ${enforcerName}`);\n  }\n\n  if (matchingCaveats.length > 1) {\n    throw new Error(\n      `Multiple caveats found with enforcer matching ${enforcerName}`,\n    );\n  }\n\n  const [{ terms, args }] = matchingCaveats as unknown as [\n    { terms: Hex; args: Hex },\n  ];\n\n  return {\n    terms,\n    args,\n  };\n}\n\n/**\n * Gets the delegation manager address from environment.\n *\n * @param environment - The SmartAccountsEnvironment.\n * @returns The delegation manager address.\n */\nfunction getDelegationManager(environment: SmartAccountsEnvironment): Address {\n  if (!environment.DelegationManager) {\n    throw new Error('Delegation manager address not found');\n  }\n\n  return environment.DelegationManager;\n}\n\n/**\n * Gets the enforcer address from environment.\n *\n * @param config - The configuration object.\n * @param config.enforcerName - The name of the enforcer.\n * @param config.environment - The SmartAccountsEnvironment.\n * @returns The enforcer address.\n */\nfunction getEnforcerAddress({\n  enforcerName,\n  environment,\n}: {\n  enforcerName: keyof SmartAccountsEnvironment['caveatEnforcers'];\n  environment: SmartAccountsEnvironment;\n}): Address {\n  const enforcerAddress = environment.caveatEnforcers[enforcerName];\n  if (!enforcerAddress) {\n    throw new Error(`${enforcerName} not found in environment`);\n  }\n\n  return enforcerAddress;\n}\n\n/**\n * Get available amount for ERC20 period transfer enforcer.\n *\n * @param client - The viem client.\n * @param environment - The SmartAccountsEnvironment.\n * @param params - The parameters for the ERC20 period transfer enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getErc20PeriodTransferEnforcerAvailableAmount(\n  client: Client,\n  environment: SmartAccountsEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'ERC20PeriodTransferEnforcer';\n\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return ERC20PeriodTransferEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n  });\n}\n\n/**\n * Get available amount for ERC20 streaming enforcer.\n *\n * @param client - The viem client.\n * @param environment - The SmartAccountsEnvironment.\n * @param params - The parameters for the ERC20 streaming enforcer.\n * @returns Promise resolving to the streaming result.\n */\nexport async function getErc20StreamingEnforcerAvailableAmount(\n  client: Client,\n  environment: SmartAccountsEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<StreamingResult> {\n  const enforcerName = 'ERC20StreamingEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return ERC20StreamingEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationManager,\n    delegationHash,\n    terms,\n  });\n}\n\n/**\n * Get available amount for multi-token period enforcer.\n *\n * @param client - The viem client.\n * @param environment - The SmartAccountsEnvironment.\n * @param params - The parameters for the multi-token period enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getMultiTokenPeriodEnforcerAvailableAmount(\n  client: Client,\n  environment: SmartAccountsEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'MultiTokenPeriodEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms, args } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return MultiTokenPeriodEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n    args,\n  });\n}\n\n/**\n * Get available amount for native token period transfer enforcer.\n *\n * @param client - The viem client.\n * @param environment - The SmartAccountsEnvironment.\n * @param params - The parameters for the native token period transfer enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getNativeTokenPeriodTransferEnforcerAvailableAmount(\n  client: Client,\n  environment: SmartAccountsEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'NativeTokenPeriodTransferEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return NativeTokenPeriodTransferEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n  });\n}\n\n/**\n * Get available amount for native token streaming enforcer.\n *\n * @param client - The viem client.\n * @param environment - The SmartAccountsEnvironment.\n * @param params - The parameters for the native token streaming enforcer.\n * @returns Promise resolving to the streaming result.\n */\nexport async function getNativeTokenStreamingEnforcerAvailableAmount(\n  client: Client,\n  environment: SmartAccountsEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<StreamingResult> {\n  const enforcerName = 'NativeTokenStreamingEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return NativeTokenStreamingEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationManager,\n    delegationHash,\n    terms,\n  });\n}\n\n/**\n * Caveat enforcer actions for extending viem clients.\n *\n * @param params - The parameters object.\n * @param params.environment - The SmartAccountsEnvironment.\n * @returns A function that takes a client and returns the client extension with caveat enforcer actions.\n */\nexport const caveatEnforcerActions =\n  ({ environment }: { environment: SmartAccountsEnvironment }) =>\n  (client: Client) => ({\n    /**\n     * Get available amount for ERC20 period transfer enforcer.\n     *\n     * @param params - The parameters for the ERC20 period transfer enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getErc20PeriodTransferEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getErc20PeriodTransferEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for ERC20 streaming enforcer.\n     *\n     * @param params - The parameters for the ERC20 streaming enforcer.\n     * @returns Promise resolving to the streaming result.\n     */\n    getErc20StreamingEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<StreamingResult> => {\n      return getErc20StreamingEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for multi-token period enforcer.\n     *\n     * @param params - The parameters for the multi-token period enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getMultiTokenPeriodEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getMultiTokenPeriodEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for native token period transfer enforcer.\n     *\n     * @param params - The parameters for the native token period transfer enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getNativeTokenPeriodTransferEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getNativeTokenPeriodTransferEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for native token streaming enforcer.\n     *\n     * @param params - The parameters for the native token streaming enforcer.\n     * @returns Promise resolving to the streaming result.\n     */\n    getNativeTokenStreamingEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<StreamingResult> => {\n      return getNativeTokenStreamingEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n  });\n","import type { Client, Address, Hex } from 'viem';\nimport { isAddressEqual } from 'viem';\nimport { getCode } from 'viem/actions';\n\nimport type { SmartAccountsEnvironment } from '../types';\n\n// EIP-7702 delegation prefix (0xef0100)\nconst DELEGATION_PREFIX = '0xef0100' as const;\n\n/**\n * Parameters for checking if an account is delegated to the EIP-7702 implementation.\n */\nexport type IsValid7702ImplementationParameters = {\n  /** The client to use for the query. */\n  client: Client;\n  /** The address to check for proper delegation. */\n  accountAddress: Address;\n  /** The SmartAccountsEnvironment containing contract addresses. */\n  environment: SmartAccountsEnvironment;\n};\n\n/**\n * Extracts the delegated contract address from EIP-7702 delegation code.\n *\n * @param code - The code returned from getCode for a delegated account.\n * @returns The delegated contract address or null if not a valid delegation.\n */\nfunction extractDelegatedAddress(code: Hex | undefined): Address | null {\n  if (code?.length !== 48) {\n    // 0x (2 chars) + ef0100 (6 chars) + address (40 chars) = 48 chars\n    return null;\n  }\n\n  if (!code.toLowerCase().startsWith(DELEGATION_PREFIX.toLowerCase())) {\n    return null;\n  }\n\n  // Extract the 20-byte address after the delegation prefix\n  const addressHex = code.slice(8); // Remove '0xef0100' prefix (8 chars)\n  return `0x${addressHex}`;\n}\n\n/**\n * Checks if an account is properly delegated to the EIP-7702 implementation.\n *\n * This function validates EIP-7702 delegations by checking if the EOA has a 7702\n * contract assigned to it and comparing the delegated address against the 7702\n * implementation found in the environment.\n *\n * @param params - The parameters for checking the delegation.\n * @param params.client - The client to use for the query.\n * @param params.accountAddress - The address to check for proper delegation.\n * @param params.environment - The SmartAccountsEnvironment containing contract addresses.\n * @returns A promise that resolves to true if the account is properly delegated to the 7702 implementation, false otherwise.\n * @example\n * ```typescript\n * const isValid = await isValid7702Implementation({\n *   client: publicClient,\n *   accountAddress: '0x...',\n *   environment: smartAccountEnvironment,\n * });\n *\n * if (isValid) {\n *   console.log('Account is properly delegated to EIP-7702 implementation');\n * } else {\n *   console.log('Account is not properly delegated');\n * }\n * ```\n */\nexport async function isValid7702Implementation({\n  client,\n  accountAddress,\n  environment,\n}: IsValid7702ImplementationParameters): Promise<boolean> {\n  try {\n    // Get the code at the account address\n    const code = await getCode(client, {\n      address: accountAddress,\n    });\n\n    // Extract the delegated contract address from the EIP-7702 delegation code\n    const delegatedAddress = extractDelegatedAddress(code);\n\n    // If no valid delegation found, return false\n    if (!delegatedAddress) {\n      return false;\n    }\n\n    // Compare the delegated address with the 7702 implementation in the environment\n    const expectedImplementation =\n      environment.implementations.EIP7702StatelessDeleGatorImpl;\n    if (!expectedImplementation) {\n      return false;\n    }\n\n    return isAddressEqual(delegatedAddress, expectedImplementation);\n  } catch {\n    // If the call fails (e.g., no code at address, network error),\n    // then it's not properly delegated to our implementation\n    return false;\n  }\n}\n","import type {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { BaseError } from 'viem';\nimport { parseAccount } from 'viem/accounts';\n\nimport { prepareSignDelegationTypedData } from '../delegation';\nimport type { Delegation } from '../types';\n\nexport type SignDelegationParameters = {\n  /** Account to sign with */\n  account?: Account | Address;\n  /** The delegation to sign */\n  delegation: Omit<Delegation, 'signature'>;\n  /** The address of the delegation manager contract */\n  delegationManager: Address;\n  /** The chain ID for the signature */\n  chainId: number;\n  /** The name of the contract */\n  name?: string;\n  /** The version of the contract */\n  version?: string;\n  /** Whether to allow insecure unrestricted delegation */\n  allowInsecureUnrestrictedDelegation?: boolean;\n};\n\nexport type SignDelegationReturnType = Hex;\n\n/**\n * Signs a delegation using a wallet client.\n *\n * @param client - The wallet client to use for signing.\n * @param parameters - The parameters for signing the delegation.\n * @returns The signature of the delegation.\n * @example\n * ```ts\n * const signature = await signDelegation(walletClient, {\n *   delegation: {\n *     delegate: '0x...',\n *     delegator: '0x...',\n *     authority: '0x...',\n *     caveats: [],\n *     salt: '0x'\n *   },\n *   delegationManager: '0x...',\n *   chainId: 1\n * });\n * ```\n */\nexport async function signDelegation<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount> & {\n    signTypedData: WalletClient['signTypedData'];\n  },\n  parameters: SignDelegationParameters,\n): Promise<SignDelegationReturnType> {\n  const {\n    account: accountParam = client.account,\n    delegation,\n    delegationManager,\n    chainId,\n    name = 'DelegationManager',\n    version = '1',\n    allowInsecureUnrestrictedDelegation = false,\n  } = parameters;\n\n  if (!accountParam) {\n    throw new BaseError('Account not found. Please provide an account.');\n  }\n\n  const account = parseAccount(accountParam);\n\n  const typedData = prepareSignDelegationTypedData({\n    delegation,\n    delegationManager,\n    chainId,\n    name,\n    version,\n    allowInsecureUnrestrictedDelegation,\n  });\n\n  return client.signTypedData({\n    account,\n    ...typedData,\n  });\n}\n\n/**\n * Creates a sign delegation action that can be used to extend a wallet client.\n *\n * @returns A function that can be used with wallet client extend method.\n * @example\n * ```ts\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http()\n * }).extend(signDelegationActions());\n * ```\n */\nexport function signDelegationActions() {\n  return <\n    TChain extends Chain | undefined,\n    TAccount extends Account | undefined,\n  >(\n    client: Client<Transport, TChain, TAccount> & {\n      signTypedData: WalletClient['signTypedData'];\n    },\n  ) => ({\n    signDelegation: async (\n      parameters: Omit<SignDelegationParameters, 'chainId'> & {\n        chainId?: number;\n      },\n    ) =>\n      signDelegation(client, {\n        chainId:\n          parameters.chainId ??\n          (() => {\n            if (!client.chain?.id) {\n              throw new BaseError(\n                'Chain ID is required. Either provide it in parameters or configure the client with a chain.',\n              );\n            }\n            return client.chain.id;\n          })(),\n        ...parameters,\n      }),\n  });\n}\n","import type {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { BaseError } from 'viem';\nimport { parseAccount } from 'viem/accounts';\n\nimport { prepareSignUserOperationTypedData } from '../userOp';\nimport type { UserOperationV07 } from '../userOp';\n\nexport type SignUserOperationParameters = {\n  /** Account to sign with */\n  account?: Account | Address;\n  /** The user operation to sign */\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  /** The entry point contract address */\n  entryPoint: { address: Address };\n  /** The chain ID that the entry point is deployed on */\n  chainId: number;\n  /** The address of the smart account */\n  address: Address;\n  /** The name of the domain of the implementation contract */\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  /** The version of the domain of the implementation contract */\n  version?: string;\n};\n\nexport type SignUserOperationReturnType = Hex;\n\n/**\n * Signs a user operation using a wallet client.\n *\n * @param client - The wallet client to use for signing.\n * @param parameters - The parameters for signing the user operation.\n * @returns The signature of the user operation.\n * @example\n * ```ts\n * const signature = await signUserOperation(walletClient, {\n *   userOperation: {\n *     sender: '0x...',\n *     nonce: 0n,\n *     callData: '0x',\n *     callGasLimit: 1000000n,\n *     verificationGasLimit: 1000000n,\n *     preVerificationGas: 21000n,\n *     maxFeePerGas: 1000000000n,\n *     maxPriorityFeePerGas: 1000000000n\n *   },\n *   entryPoint: { address: '0x...' },\n *   chainId: 1,\n *   address: '0x...',\n *   name: 'HybridDeleGator'\n * });\n * ```\n */\nexport async function signUserOperation<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount> & {\n    signTypedData: WalletClient['signTypedData'];\n  },\n  parameters: SignUserOperationParameters,\n): Promise<SignUserOperationReturnType> {\n  const {\n    account: accountParam = client.account,\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version = '1',\n  } = parameters;\n\n  if (!accountParam) {\n    throw new BaseError('Account not found. Please provide an account.');\n  }\n\n  const account = parseAccount(accountParam);\n\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return client.signTypedData({\n    account,\n    ...typedData,\n  });\n}\n\n/**\n * Creates a sign user operation action that can be used to extend a wallet client.\n *\n * @returns A function that can be used with wallet client extend method.\n * @example\n * ```ts\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http()\n * }).extend(signUserOperationActions());\n * ```\n */\nexport function signUserOperationActions() {\n  return <\n    TChain extends Chain | undefined,\n    TAccount extends Account | undefined,\n  >(\n    client: Client<Transport, TChain, TAccount> & {\n      signTypedData: WalletClient['signTypedData'];\n    },\n  ) => ({\n    signUserOperation: async (\n      parameters: Omit<SignUserOperationParameters, 'chainId'> & {\n        chainId?: number;\n      },\n    ) =>\n      signUserOperation(client, {\n        chainId:\n          parameters.chainId ??\n          (() => {\n            if (!client.chain?.id) {\n              throw new BaseError(\n                'Chain ID is required. Either provide it in parameters or configure the client with a chain.',\n              );\n            }\n            return client.chain.id;\n          })(),\n        ...parameters,\n      }),\n  });\n}\n"]}