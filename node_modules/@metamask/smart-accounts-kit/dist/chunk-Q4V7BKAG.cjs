"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

var _chunkVLKX4BR6cjs = require('./chunk-VLKX4BR6.cjs');


var _chunkMIP7KJYHcjs = require('./chunk-MIP7KJYH.cjs');

// src/write.ts
var _delegationabis = require('@metamask/delegation-abis');
var redeemDelegations = async (walletClient, publicClient, delegationManagerAddress, redemptions) => {
  if (redemptions.length === 0) {
    throw new Error("RedeemDelegations invalid zero redemptions");
  }
  const permissionContexts = [];
  const executionsBatch = [];
  const executionModes = [];
  redemptions.forEach((redemption) => {
    permissionContexts.push(redemption.permissionContext);
    executionsBatch.push(redemption.executions);
    executionModes.push(redemption.mode);
  });
  const encodedPermissionContexts = _chunkMIP7KJYHcjs.encodePermissionContexts.call(void 0, permissionContexts);
  const executionCalldatas = _chunkVLKX4BR6cjs.encodeExecutionCalldatas.call(void 0, executionsBatch);
  const { request } = await publicClient.simulateContract({
    account: walletClient.account,
    address: delegationManagerAddress,
    abi: _delegationabis.DelegationManager,
    functionName: "redeemDelegations",
    args: [encodedPermissionContexts, executionModes, executionCalldatas]
  });
  return await walletClient.writeContract(request);
};
async function deployContract(walletClient, publicClient, chain, { bytecode, abi }, args = []) {
  if (!walletClient.account) {
    throw new Error("Wallet client account is required");
  }
  const hash = await walletClient.deployContract({
    abi,
    bytecode,
    args,
    account: walletClient.account,
    chain
  });
  const receipt = await publicClient.waitForTransactionReceipt({
    hash
  });
  if (!receipt.contractAddress) {
    throw new Error("No contract address in receipt");
  }
  return { address: receipt.contractAddress, hash, receipt };
}

// src/smartAccountsEnvironment.ts















































































var _bytecode = require('@metamask/delegation-abis/bytecode');
var _delegationdeployments = require('@metamask/delegation-deployments');
var PREFERRED_VERSION = "1.3.0";
var contractOverrideMap = /* @__PURE__ */ new Map();
var getContractOverrideKey = (chainId, version) => `${version}:${chainId}`;
function overrideDeployedEnvironment(chainId, version, environment) {
  contractOverrideMap.set(
    getContractOverrideKey(chainId, version),
    environment
  );
}
function getSmartAccountsEnvironment(chainId, version = PREFERRED_VERSION) {
  const overrideKey = getContractOverrideKey(chainId, version);
  const overriddenContracts = contractOverrideMap.get(overrideKey);
  if (overriddenContracts) {
    return overriddenContracts;
  }
  const contracts = _optionalChain([_delegationdeployments.DELEGATOR_CONTRACTS, 'access', _ => _[version], 'optionalAccess', _2 => _2[chainId]]);
  if (!contracts) {
    throw new Error(
      `No contracts found for version ${version} chain ${chainId}`
    );
  }
  return getSmartAccountsEnvironmentV1(contracts);
}
function getSmartAccountsEnvironmentV1(contracts) {
  return {
    DelegationManager: contracts.DelegationManager,
    EntryPoint: contracts.EntryPoint,
    SimpleFactory: contracts.SimpleFactory,
    implementations: {
      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,
      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,
      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl
    },
    caveatEnforcers: {
      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,
      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,
      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,
      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,
      BlockNumberEnforcer: contracts.BlockNumberEnforcer,
      DeployedEnforcer: contracts.DeployedEnforcer,
      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,
      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,
      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,
      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,
      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,
      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,
      IdEnforcer: contracts.IdEnforcer,
      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,
      NonceEnforcer: contracts.NonceEnforcer,
      TimestampEnforcer: contracts.TimestampEnforcer,
      ValueLteEnforcer: contracts.ValueLteEnforcer,
      NativeTokenTransferAmountEnforcer: contracts.NativeTokenTransferAmountEnforcer,
      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,
      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,
      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,
      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,
      RedeemerEnforcer: contracts.RedeemerEnforcer,
      SpecificActionERC20TransferBatchEnforcer: contracts.SpecificActionERC20TransferBatchEnforcer,
      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,
      NativeTokenPeriodTransferEnforcer: contracts.NativeTokenPeriodTransferEnforcer,
      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,
      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,
      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,
      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,
      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer
    }
  };
}
async function deploySmartAccountsEnvironment(walletClient, publicClient, chain, deployedContracts = {}) {
  const deployContractCurried = async (name, contract, params = []) => {
    const existingAddress = deployedContracts[name];
    if (existingAddress) {
      return {
        address: existingAddress,
        name
      };
    }
    const deployedContract = await deployContract(
      walletClient,
      publicClient,
      chain,
      contract,
      params
    );
    const newDeployedContracts = { ...deployedContracts };
    newDeployedContracts[name] = deployedContract.address;
    Object.assign(deployedContracts, newDeployedContracts);
    return { ...deployedContract, name };
  };
  const standaloneContracts = {
    SimpleFactory: {
      abi: _delegationabis.SimpleFactory,
      bytecode: _bytecode.SimpleFactory
    },
    AllowedCalldataEnforcer: {
      abi: _delegationabis.AllowedCalldataEnforcer,
      bytecode: _bytecode.AllowedCalldataEnforcer
    },
    AllowedTargetsEnforcer: {
      abi: _delegationabis.AllowedTargetsEnforcer,
      bytecode: _bytecode.AllowedTargetsEnforcer
    },
    AllowedMethodsEnforcer: {
      abi: _delegationabis.AllowedMethodsEnforcer,
      bytecode: _bytecode.AllowedMethodsEnforcer
    },
    ArgsEqualityCheckEnforcer: {
      abi: _delegationabis.ArgsEqualityCheckEnforcer,
      bytecode: _bytecode.ArgsEqualityCheckEnforcer
    },
    DeployedEnforcer: {
      abi: _delegationabis.DeployedEnforcer,
      bytecode: _bytecode.DeployedEnforcer
    },
    TimestampEnforcer: {
      abi: _delegationabis.TimestampEnforcer,
      bytecode: _bytecode.TimestampEnforcer
    },
    BlockNumberEnforcer: {
      abi: _delegationabis.BlockNumberEnforcer,
      bytecode: _bytecode.BlockNumberEnforcer
    },
    LimitedCallsEnforcer: {
      abi: _delegationabis.LimitedCallsEnforcer,
      bytecode: _bytecode.LimitedCallsEnforcer
    },
    ERC20BalanceChangeEnforcer: {
      abi: _delegationabis.ERC20BalanceChangeEnforcer,
      bytecode: _bytecode.ERC20BalanceChangeEnforcer
    },
    ERC20TransferAmountEnforcer: {
      abi: _delegationabis.ERC20TransferAmountEnforcer,
      bytecode: _bytecode.ERC20TransferAmountEnforcer
    },
    ERC20StreamingEnforcer: {
      abi: _delegationabis.ERC20StreamingEnforcer,
      bytecode: _bytecode.ERC20StreamingEnforcer
    },
    ERC721BalanceChangeEnforcer: {
      abi: _delegationabis.ERC721BalanceChangeEnforcer,
      bytecode: _bytecode.ERC721BalanceChangeEnforcer
    },
    ERC721TransferEnforcer: {
      abi: _delegationabis.ERC721TransferEnforcer,
      bytecode: _bytecode.ERC721TransferEnforcer
    },
    ERC1155BalanceChangeEnforcer: {
      abi: _delegationabis.ERC1155BalanceChangeEnforcer,
      bytecode: _bytecode.ERC1155BalanceChangeEnforcer
    },
    IdEnforcer: { abi: _delegationabis.IdEnforcer, bytecode: _bytecode.IdEnforcer },
    NonceEnforcer: {
      abi: _delegationabis.NonceEnforcer,
      bytecode: _bytecode.NonceEnforcer
    },
    ValueLteEnforcer: {
      abi: _delegationabis.ValueLteEnforcer,
      bytecode: _bytecode.ValueLteEnforcer
    },
    NativeTokenTransferAmountEnforcer: {
      abi: _delegationabis.NativeTokenTransferAmountEnforcer,
      bytecode: _bytecode.NativeTokenTransferAmountEnforcer
    },
    NativeBalanceChangeEnforcer: {
      abi: _delegationabis.NativeBalanceChangeEnforcer,
      bytecode: _bytecode.NativeBalanceChangeEnforcer
    },
    NativeTokenStreamingEnforcer: {
      abi: _delegationabis.NativeTokenStreamingEnforcer,
      bytecode: _bytecode.NativeTokenStreamingEnforcer
    },
    OwnershipTransferEnforcer: {
      abi: _delegationabis.OwnershipTransferEnforcer,
      bytecode: _bytecode.OwnershipTransferEnforcer
    },
    RedeemerEnforcer: {
      abi: _delegationabis.RedeemerEnforcer,
      bytecode: _bytecode.RedeemerEnforcer
    },
    SpecificActionERC20TransferBatchEnforcer: {
      abi: _delegationabis.SpecificActionERC20TransferBatchEnforcer,
      bytecode: _bytecode.SpecificActionERC20TransferBatchEnforcer
    },
    ERC20PeriodTransferEnforcer: {
      abi: _delegationabis.ERC20PeriodTransferEnforcer,
      bytecode: _bytecode.ERC20PeriodTransferEnforcer
    },
    NativeTokenPeriodTransferEnforcer: {
      abi: _delegationabis.NativeTokenPeriodTransferEnforcer,
      bytecode: _bytecode.NativeTokenPeriodTransferEnforcer
    },
    ExactCalldataBatchEnforcer: {
      abi: _delegationabis.ExactCalldataBatchEnforcer,
      bytecode: _bytecode.ExactCalldataBatchEnforcer
    },
    ExactCalldataEnforcer: {
      abi: _delegationabis.ExactCalldataEnforcer,
      bytecode: _bytecode.ExactCalldataEnforcer
    },
    ExactExecutionEnforcer: {
      abi: _delegationabis.ExactExecutionEnforcer,
      bytecode: _bytecode.ExactExecutionEnforcer
    },
    ExactExecutionBatchEnforcer: {
      abi: _delegationabis.ExactExecutionBatchEnforcer,
      bytecode: _bytecode.ExactExecutionBatchEnforcer
    },
    MultiTokenPeriodEnforcer: {
      abi: _delegationabis.MultiTokenPeriodEnforcer,
      bytecode: _bytecode.MultiTokenPeriodEnforcer
    }
  };
  for (const [name, contract] of Object.entries(standaloneContracts)) {
    await deployContractCurried(name, contract);
  }
  const delegationManager = await deployContractCurried(
    "DelegationManager",
    { abi: _delegationabis.DelegationManager, bytecode: _bytecode.DelegationManager },
    [_optionalChain([walletClient, 'access', _3 => _3.account, 'optionalAccess', _4 => _4.address])]
  );
  await deployContractCurried(
    "NativeTokenPaymentEnforcer",
    {
      abi: _delegationabis.NativeTokenPaymentEnforcer,
      bytecode: _bytecode.NativeTokenPaymentEnforcer
    },
    [delegationManager.address, deployedContracts.ArgsEqualityCheckEnforcer]
  );
  const entryPoint = await deployContractCurried("EntryPoint", {
    abi: _delegationabis.EntryPoint,
    bytecode: _bytecode.EntryPoint
  });
  const { address: sclRIP7212 } = await deployContract(
    walletClient,
    publicClient,
    chain,
    { abi: _delegationabis.SCL_RIP7212, bytecode: _bytecode.SCL_RIP7212 },
    []
  );
  const hybridDeleGatorWithLinkedLibrary = {
    abi: _delegationabis.HybridDeleGator,
    bytecode: _bytecode.HybridDeleGator.replace(
      /__\$b8f96b288d4d0429e38b8ed50fd423070f\$__/gu,
      sclRIP7212.slice(2)
    )
  };
  await deployContractCurried(
    "HybridDeleGatorImpl",
    hybridDeleGatorWithLinkedLibrary,
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried(
    "MultiSigDeleGatorImpl",
    {
      abi: _delegationabis.MultiSigDeleGator,
      bytecode: _bytecode.MultiSigDeleGator
    },
    [delegationManager.address, entryPoint.address]
  );
  await deployContractCurried(
    "EIP7702StatelessDeleGatorImpl",
    {
      abi: _delegationabis.EIP7702StatelessDeleGator,
      bytecode: _bytecode.EIP7702StatelessDeleGator
    },
    [delegationManager.address, entryPoint.address]
  );
  return getSmartAccountsEnvironmentV1(deployedContracts);
}

// src/userOp.ts
var _viem = require('viem');
var _accountabstraction = require('viem/account-abstraction');
var _accounts = require('viem/accounts');
var SIGNABLE_USER_OP_TYPED_DATA = {
  PackedUserOperation: [
    { name: "sender", type: "address" },
    { name: "nonce", type: "uint256" },
    { name: "initCode", type: "bytes" },
    { name: "callData", type: "bytes" },
    { name: "accountGasLimits", type: "bytes32" },
    { name: "preVerificationGas", type: "uint256" },
    { name: "gasFees", type: "bytes32" },
    { name: "paymasterAndData", type: "bytes" },
    { name: "entryPoint", type: "address" }
  ]
};
var prepareSignUserOperationTypedData = ({
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const packedUserOp = _accountabstraction.toPackedUserOperation.call(void 0, {
    ...userOperation,
    signature: "0x"
  });
  return {
    domain: {
      chainId,
      name,
      version,
      verifyingContract: address
    },
    types: SIGNABLE_USER_OP_TYPED_DATA,
    primaryType: "PackedUserOperation",
    message: { ...packedUserOp, entryPoint: entryPoint.address }
  };
};
var signUserOperation = async ({
  privateKey,
  userOperation,
  entryPoint,
  chainId,
  name,
  address,
  version = "1"
}) => {
  const typedData = prepareSignUserOperationTypedData({
    userOperation,
    entryPoint,
    chainId,
    name,
    address,
    version
  });
  return _accounts.signTypedData.call(void 0, {
    privateKey,
    ...typedData
  });
};










exports.redeemDelegations = redeemDelegations; exports.PREFERRED_VERSION = PREFERRED_VERSION; exports.overrideDeployedEnvironment = overrideDeployedEnvironment; exports.getSmartAccountsEnvironment = getSmartAccountsEnvironment; exports.deploySmartAccountsEnvironment = deploySmartAccountsEnvironment; exports.SIGNABLE_USER_OP_TYPED_DATA = SIGNABLE_USER_OP_TYPED_DATA; exports.prepareSignUserOperationTypedData = prepareSignUserOperationTypedData; exports.signUserOperation = signUserOperation;
//# sourceMappingURL=chunk-Q4V7BKAG.cjs.map